#lang racket
(require racket/trace)
;The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

;1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

;Let us list the factors of the first seven triangle numbers:

; 1: 1
; 3: 1,3
; 6: 1,2,3,6
; 10: 1,2,5,10
; 15: 1,3,5,15
; 21: 1,3,7,21
; 28: 1,2,4,7,14,28

;We can see that 28 is the first triangle number to have over five divisors.

;What is the value of the first triangle number to have over five hundred divisors?

; integer -> integer
; return 1+2+...+n
(define (sumto n)
  (/ (* n (+ n 1)) 2))

; integer -> list
; return a list of the prime factors of the integer
(define (pfactor n)
  (let loop ((i 2) (v n) (rs '()))
        (cond
          ((>= i v) (cons i rs))
          ((integer? (/ v i))
           (loop i (/ v i) (cons i rs)))
          (else (loop (+ i 1) v rs)))))

; list -> list of list
; return the power set of the set
(define (powerset lst)
  (define (addtoeach e llst)
        (if (null? (cdr llst))
          (list '() (list e))
          (append llst (for/list ((term llst)) (append term (list e))))))
  (if (null? lst)
        '(())
        (addtoeach (car lst) (powerset (cdr lst)))))

; list of list -> list of list
; map input element to the mulitple of the elements in it
(define (prod llst)
  (cond
        ((null? llst) '())
        ((null? (car llst)) (prod (cdr llst)))
        ((= 1 (length (car llst))) (cons (car llst) (prod (cdr llst))))
        (else (cons (list (apply * (car llst))) (prod (cdr llst))))))

; main routine
(let loop ((i 2))
  (let* ((triangle (sumto i))
                ; find the prime factors of triangle
                ; rise it to the power set
                 (bang (powerset (pfactor triangle)))
                 ; we get a list of multiple of the prime factors
                 ; remove those values that can't divide triangle
                 (factors
                   (filter (lambda (x) (integer? (/ triangle (car x))))
                                   (prod bang)))
                 ; remove duplicate values
                 ; now get a list of all the divisors of triangle exclude 1
                 (set (let inner ((rm factors) (rs '()))
                                (cond
                                  ((null? rm) rs)
                                  ((null? (caar rm)) (inner (cdr rm) rs))
                                  ((memv (caar rm) rs) (inner (cdr rm) rs))
                                  (else (inner (cdr rm) (cons (caar rm) rs))))))
                 (target-number-of-divisor 500))
        (if (>= (length set) target-number-of-divisor)
          (values triangle) ; (values triangle set)
          (loop (+ i 1)))))

;cpu time: 5766 real time: 5765 gc time: 374 measure in millisecond

;回头看自己用racket做的这道题，竟然用到幂集还好问题规模不大...